const { promisify } = require("util");
const { json, response } = require("express");
const crypto = require("crypto");
const catchAsync = require("./../utils/catchAysnc");
const sendEmail = require("./../utils/email");
const jwt = require("jsonwebtoken");
//APIFeature gives us the filter,sort,limitfields and pagination which is used in getAll tours

const User = require("./../modals/userModal");
const AppError = require("../utils/appError");

const signToken = (id) => {
  const token = jwt.sign({ id: id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE,
  });
  return token;
};

const createSendToken = (user, statuscode, res, message, showUser = true) => {
  const token = signToken(user._id);

  const cookieOption = {
    expires: new Date(
      Date.now() + process.env.JWT_COOKIE_EXPIRES_IN * 24 * 60 * 60 * 1000
    ),

    httpOnly: true,
  };
  if (process.env.NODE_ENV === "production") secure = true;
  res.cookie("jwt", token, cookieOption);

  user.password = undefined;
  user.active = undefined;

  const response = {
    status: "Success",
    message: message,
    token,
  };

  if (showUser) {
    response.data = {
      data: {
        User: user,
      },
    };
  }
  res.cookie;
  res.status(statuscode).json(response);
};

// this is sign up feature for user
exports.signup = catchAsync(async (req, res, next) => {
  const newUser = await User.create({
    name: req.body.name,
    email: req.body.email,
    password: req.body.password,
    confirmPassword: req.body.confirmPassword,
    phoneNumber: req.body.phoneNumber,
    role: req.body.role,
  });
  const message = "user Created";
  createSendToken(newUser, 201, res, message, true);
});

// Login functionality for user
exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;
  //1st check if email and pass
  if (!email || !password) {
    return next(new AppError("Please provide Email and Password", 400));
  }

  //2nd check is email and password are correct
  const user = await User.findOne({ email }).select("+password");

  if (!user || !(await user.correctPassword(password, user.password)))
    return next(new AppError("Kindly Enter Correct User and Password", 401));

  //3rd send token if both are ok
  const message = "user Loggedin";
  createSendToken(user, 200, res, message, false);
});

//functionality to get all user

// this is middle ware function to check weather the authorization token present is valid or not
exports.protect = catchAsync(async (req, res, next) => {
  const header = req.headers.authorization;
  let token;
  //1st getting token and check if it's there.
  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    token = req.headers.authorization.split(" ")[1];
  }
  if (!token) return next(new AppError("Kindly login to get access", 401));
  //2nd  verify token.
  const decoder = await promisify(jwt.verify)(token, process.env.JWT_SECRET);

  //**in decoder we will get id, tocken creation and expire time from payload */

  //3rd check if user still exist.
  const currentuser = await User.findById(decoder.id);
  if (!currentuser)
    return next(new AppError("User belong to this token no longer Eixt", 401));
  //4th check if user changed the password after token was issued.
  if (currentuser.changedPasswordAfter(decoder.iat))
    return next(
      new AppError("User recently changed the password! Please try again", 401)
    );

  req.user = currentuser;
  next();
});

// this method is restricting the user to delete tour or user from the tour modal basically here we can define some with special features like admin role
exports.restrictTO = (...role) => {
  return (req, res, next) => {
    // const role = req.user.role;zz
    if (!role.includes(req.user.role)) {
      console.log(role);

      if (role[0] === "user") {
        return next(
          new AppError(
            " ADMIN Team and lead-guide are not allowed to use this feature ðŸ˜’!!!",
            401
          )
        );
      } else {
        return next(
          new AppError(
            "Only admin team is Authorized to make Create,Edit & Delete Tours, Kindly Contact ADMIN Team for any Support or Query!!!",
            401
          )
        );
      }
    }
    next();
  };
};

// Here we are using nodemailer to send a token which is generated by crypto random bytes method to generate the token
//later we are encrypting the token by crypto create hash and storing it in to db, and sending the normal token to user via email through nodemailer
//Ques: we are storing the encrpted token in db so it can violet security later we match the normal token with encrtpted one and change db password

exports.forgotPassword = catchAsync(async (req, res, next) => {
  //1. get user based on Email
  const email = req.body.email;
  const user = await User.findOne({ email });

  if (!user) {
    return next(new AppError("No user Found", 404));
  }

  //2. Generate Token
  const token = user.createPassWordResetToken();
  await user.save({ validateBeforeSave: false });

  //3. Send an email token to user
  const resetURL = `${req.protocol}://${req.get(
    "host"
  )}/api/v1/users/resetPassword/${token}`;
  const message = `Forgot your password? Submit a patch request with new Password and confirm Password to ${resetURL}, If Its not You Kindly ignore this Email `;

  try {
    await sendEmail({
      email: user.email,
      subject: "Token for Restting Password valid for 10 Minutes!!!",
      message,
    });

    res.status(200).json({
      status: "Success",
      message: "Token  to email",
    });
  } catch (error) {
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save({ validateBoforeSave: false });
    next(
      new AppError(
        "We are Facing some TechnicalError, Kindly try after some time",
        500
      )
    );
  }
});

//Restet Password functionality here we are taking the token sent on email and converting the token to crypto encrypt then matching if user has this same encrypted password reset token then changing and confirming password and updating it into db
exports.resetPassword = catchAsync(async (req, res, next) => {
  //1. Get user based on token
  const hashedToken = crypto
    .createHash("sha256")
    .update(req.params.token)
    .digest("hex");
  const user = await User.findOne({
    passwordResetToken: hashedToken,
    // passwordResetExpires: { $gte: Date.now() },  can be used to verify token and checking if its not expired yet
  });

  //verify is its a valid token
  if (!user) return next(new AppError(`User not Found`, 404));

  //2.verify if token is not expired
  if (user.passwordResetExpires < Date.now()) {
    return next(new AppError("Token for resetting Password is Expired", 404));
  }

  //3.if user is valid reset and save the token
  user.password = req.body.password;
  user.confirmPassword = req.body.confirmPassword;
  user.passwordResetExpires = undefined;
  user.passwordResetToken = undefined;
  await user.save();

  // const token = signToken(user._id);
  const message = "Password Reseted SuccessFully";
  createSendToken(user, 200, res, message, false);
  //4.send response
  // res.status(200).json({
  //   status: "Success",
  //   message: "Password Reseted SuccessFully",
  //   token,
  // });
});

exports.updatePassword = catchAsync(async (req, res, next) => {
  //1st. Get the user
  const user = await User.findById(req.user.id).select("+password");
  if (!user) return next(new AppError(`Can't Find the user`, 404));

  //2nd. compare password of user with old password

  if (!(await user.correctPassword(req.body.oldPassword, user.password))) {
    return next(
      new AppError(`Old Password doesnot match Kindly try again!!!`, 401)
    );
  }

  user.password = req.body.currentPassword;
  user.confirmPassword = req.body.confirmPassword;
  await user.save();

  //3rd. update password and send the token
  const message = "Password Updated SuccessFully";
  createSendToken(user, 200, res, message, false);
});
